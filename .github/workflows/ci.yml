name: Main CI/CD Pipeline
on:
  push:
    branches: [main, development]
  pull_request:
    branches: [main, development]

jobs:
  # Run linting and type checking
  lint-and-type-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Run linting
        run: npm run lint
      - name: Run type checking
        run: npm run type-check
      - name: Check formatting
        run: npm run format:check

  # Run all tests
  test-all:
    runs-on: ubuntu-latest
    needs: [lint-and-type-check]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Run all tests
        run: npm test

  # Build application
  build:
    runs-on: ubuntu-latest
    needs: [lint-and-type-check]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Build application
        run: npm run build
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: .next
          retention-days: 1

  # Wait for feature tests to complete
  wait-for-feature-tests:
    runs-on: ubuntu-latest
    needs: [lint-and-type-check]
    steps:
      - name: Wait for feature tests
        run: |
          echo "Waiting for feature tests to complete..."
          # This job exists to create a dependency on the feature-tests workflow
          # The actual feature status will be retrieved from the artifact

  # Deploy to staging with feature flags
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build, test-all, wait-for-feature-tests]
    if: github.ref == 'refs/heads/development'
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: .next
      
      # Download feature status from feature-tests workflow
      - name: Download feature status
        uses: actions/download-artifact@v4
        with:
          name: feature-status
          path: ./feature-status
      
      # Configure feature flags based on test results
      - name: Configure feature flags
        run: |
          # Default all features to enabled
          echo "NEXT_PUBLIC_FEATURE_GRANTS_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_WEBINARS_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_CHAT_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_PDF_PROCESSING_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_SUBSCRIPTION_ENABLED=true" >> .env
          
          # Override with feature test results if available
          if [ -f "./feature-status/status.env" ]; then
            echo "Feature status file found, applying feature flags"
            while IFS='=' read -r key value; do
              if [ "$key" = "grants" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_GRANTS_ENABLED=false" >> .env
                echo "Disabling grants feature due to test failures"
              fi
              if [ "$key" = "webinars" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_WEBINARS_ENABLED=false" >> .env
                echo "Disabling webinars feature due to test failures"
              fi
              if [ "$key" = "chat" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_CHAT_ENABLED=false" >> .env
                echo "Disabling chat feature due to test failures"
              fi
              if [ "$key" = "pdf_processing" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_PDF_PROCESSING_ENABLED=false" >> .env
                echo "Disabling PDF processing feature due to test failures"
              fi
              if [ "$key" = "subscription" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_SUBSCRIPTION_ENABLED=false" >> .env
                echo "Disabling subscription feature due to test failures"
              fi
            done < "./feature-status/status.env"
          else
            echo "No feature status file found, using default feature flags"
          fi
          
          # Display final feature flag configuration
          echo "Final feature flag configuration:"
          cat .env
      
      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment with feature flags"
          # Add actual deployment commands here
          # This would typically use a service like Vercel, Netlify, or custom deployment scripts

  # Deploy to production with feature flags
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build, test-all, wait-for-feature-tests]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: .next
          
      # Download feature status from feature-tests workflow
      - name: Download feature status
        uses: actions/download-artifact@v4
        with:
          name: feature-status
          path: ./feature-status
      
      # Configure feature flags based on test results
      - name: Configure feature flags
        run: |
          # Default all features to enabled
          echo "NEXT_PUBLIC_FEATURE_GRANTS_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_WEBINARS_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_CHAT_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_PDF_PROCESSING_ENABLED=true" >> .env
          echo "NEXT_PUBLIC_FEATURE_SUBSCRIPTION_ENABLED=true" >> .env
          
          # Override with feature test results if available
          if [ -f "./feature-status/status.env" ]; then
            echo "Feature status file found, applying feature flags"
            while IFS='=' read -r key value; do
              if [ "$key" = "grants" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_GRANTS_ENABLED=false" >> .env
                echo "Disabling grants feature due to test failures"
              fi
              if [ "$key" = "webinars" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_WEBINARS_ENABLED=false" >> .env
                echo "Disabling webinars feature due to test failures"
              fi
              if [ "$key" = "chat" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_CHAT_ENABLED=false" >> .env
                echo "Disabling chat feature due to test failures"
              fi
              if [ "$key" = "pdf_processing" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_PDF_PROCESSING_ENABLED=false" >> .env
                echo "Disabling PDF processing feature due to test failures"
              fi
              if [ "$key" = "subscription" ] && [ "$value" = "false" ]; then
                echo "NEXT_PUBLIC_FEATURE_SUBSCRIPTION_ENABLED=false" >> .env
                echo "Disabling subscription feature due to test failures"
              fi
            done < "./feature-status/status.env"
          else
            echo "No feature status file found, using default feature flags"
          fi
          
          # Display final feature flag configuration
          echo "Final feature flag configuration:"
          cat .env
      
      - name: Deploy to production
        run: |
          echo "Deploying to production environment with feature flags"
          # Add actual deployment commands here
          # This would typically use a service like Vercel, Netlify, or custom deployment scripts